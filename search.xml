<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Netty用户指南4.x]]></title>
      <url>%2F2017%2F03%2F27%2FNetty%E6%8C%87%E5%8D%97%E4%B8%AD%E6%96%87%E7%89%88%2F</url>
      <content type="text"><![CDATA[based on User guide for 4.x 序言 Preface 问题 The Problem 如今我们使用通用的应用程序或者库来彼此通讯。比如，我们经常使用 HTTP 客户端库从远程服务器接收信息或者执行远程服务的调用。但无论如何，一个通用的协议或者它们的实现有时候可用性不是太好。这就是为什么有时候我们并不使用通用的 HTTP 协议来交换大数据、电子邮件信息以及金融数据和多人网络游戏数据这种近实时的数据。所需要的是为了一个专门的目的去实现一个高度优化的协议。比如，你可能需为了基于 AJAX 的聊天应用，媒体传输，或者大文件传输去实现一个优化的 HTTP 服务。你甚至可以为了你的需求去精确的定义并实现一个全新的协议。另外一个经常发生的情况是你必须去处理系统中遗留的专门协议去确保与旧系统的交互。这种情况下重要的是，我们如何能够快速的实现该协议，并且不会牺牲应用程序的稳定性和性能。 解决方案 The Solution Netty 是一个提供了异步事件驱动 (asynchronous event-driven) 网络应用程序框架和工具的杰作，可以用来快速开发可维护的，高性能 · 高可用的服务端和客户端协议。 从另一方面来讲，Netty 是一个可以快速开发网络程序如客户端和服务端协议的 NIO 客户端/服务端框架。它大大的简化了如 TCP 和 UDP 这类套接字服务的网络应用程序的开发并优化了其开发流程。 “快速简单”并不意味着开发出的应用程序的可维护性变差或者遇到性能问题。 Netty 从大量的如 FTP、SMPT、HTTP 以及各种二进制文本传输协议的实现中获得经验，并精心设计。因此， Netty 成功的获得了可以快速开发，并且不妥协性能、稳定性以及灵活性的方法。 一些用户用户或者发现过其他一些网络应用框架也声称有以上优势，可能会想问 Netty 和它们有何不同。答案是，设计哲学。 Netty 从一开始就设计得为你提供舒适的 API 及实现。这不是什么可感知的事务，但你会意识到这些设计哲学让你的生活变得更简单，就像你开始阅读这份指南，并且开始轻松使用 Netty 。 开始 Getting Started 本章指南围绕着 Netty 的核心结构，据一些简单的例子，让你轻松开始。本章结束后，你将可在 Netty 之上编写客户端和服务端。 如果你学习东西的时候喜欢使用自上而下分析法，那么你也许可以从第二章，架构总览开始，然后回到这里。 开始之前 Before Getting Started 要想运行本章中所引入的例子，需要两个最小的依赖：Netty 最新的稳定版 和 JDK 1.6 或者更新。Netty 最新的稳定版可以从 项目下载页面 下载。可以从 JDK 供应商的网站下载正确版本的 JDK 。 在你阅读的过程中，你可能对本章中引入的类有一些疑问。如果你想知道它们可以参考 API 文档。为了你的方便，文档中所有的类名都是引用的在线 API 文档。当然了，如果本文档中有任何错误信息，以及语法和打印中的错误，或者你有什么完善本文档的好的建议，可以联系Netty项目社区。 写一个 Discard 服务 Writing a Discard Server 世界上最简单的协议是 DISCARD ，而不是 &quot;Hello,World!&quot;。该协议丢弃任何收到的数据而不做任何回应。 要实现 DISCARD 协议，你唯一要做的事情就是忽略任何收到的消息。让我们直接从一个 handler 的实现开始，handler 是 Netty 生成的用来处理 I/O 事件的。 12345678910111213141516171819202122232425package io.netty.example.discard;import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;/** * 处理一个服务端的 channel。 */public class DiscardServerHandler extends ChannelInboundHandlerAdapter &#123; // (1) @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; // (2) // 默默的丢弃收到的数据。 ((ByteBuf) msg).release(); // (3) &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; // (4) // 当引发异常时关闭连接。 cause.printStackTrace(); ctx.close(); &#125;&#125; DiscardServerHandler 继承自 ChannelInboundHandlerAdapter，该类实现了 ChannelInboundHandler .ChannelInboundHandler 接口，提供了多种事件处理方法，你可以重写这些方法。现在，你只需要继承 ChannelInboundHandlerAdapter ,而无需自己实现接口中的处理方法。 我们重写了 channelRead() 方法。无论何时从客户端收到消息时，该方法被调用。在这个例子中，收到的消息类型是 ByteBuf 为了实现 DISCARD 协议，该处理器必须忽略收到的消息。 ByteBuf 是一个引用计数对象，所以必须显式的调用 release() 方法来释放资源。请谨记，任何传递到处理器引用计数对象，处理器都有责任将其释放掉。通常， channelRead() 方法的实现如下： 12345678@Overridepublic void channelRead(ChannelHandlerContext ctx, Object msg) &#123; try &#123; // Do something with msg &#125; finally &#123; ReferenceCountUtil.release(msg); &#125;&#125; 当 Netty 犹豫 I/O 错误或者处理器处理事件时抛出异常，导致 Throwable 对象出现时，exceptionCaught() 方法被调用。大多数情况下，补货到的异常应该被记录，与其相关的 channle 也应该在这儿被关闭，当然了，该方法的实现也会因你的不同异常处理方案而不同。比如，你也许想在关闭连接之前发送一个包含错误代码的响应消息。 目前来说一切都很好，我们实现了 DISCARD 服务的一般。现在剩下我们去在 DiscardServerHandler 中写一个 main() 方法来启动服务。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package io.netty.example.discard;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;/** * 丢弃任何进来的数据。 */public class DiscardServer &#123; private int port; public DiscardServer(int port) &#123; this.port = port; &#125; public void run() throws Exception &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); // (1) EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap b = new ServerBootstrap(); // (2) b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) // (3) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; // (4) @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new DiscardServerHandler()); &#125; &#125;) .option(ChannelOption.SO_BACKLOG, 128) // (5) .childOption(ChannelOption.SO_KEEPALIVE, true); // (6) // 绑定端口并且开始服务接收进来的连接。 ChannelFuture f = b.bind(port).sync(); // (7) // 等待 server socket 关闭。 // 在这个例子中，这不会发生，但你可以这样优雅的关闭你的服务。 f.channel().closeFuture().sync(); &#125; finally &#123; workerGroup.shutdownGracefully(); bossGroup.shutdownGracefully(); &#125; &#125; public static void main(String[] args) throws Exception &#123; int port; if (args.length &gt; 0) &#123; port = Integer.parseInt(args[0]); &#125; else &#123; port = 8080; &#125; new DiscardServer(port).run(); &#125;&#125; NioEventLoopGroup 是一个用来处理 I/O 操作的多线程事件循环器。 Netty 为不同类型传输提供了各种各样的 EventLoopGroup 的实现。这个例子我们实现了一个服务端的应用，声明了两个 NioEventLoopGroup 实例。第一个，通常称为 &quot;boss&quot;,用来接收进来的连接。第二个，通常称为 &quot;worker&quot;, 用来处理接收到连接，一旦 boss 接收到连接，就将其注册到 worker 上。使用多少个线程，如何将其映射到已经创建好的 channelS 依赖于 EventLoopGroup 的实现，也可以通过构造方法进行配置。 ServerBootstrap 是一个建立 server 的辅助类。你也可以通过 Channel 直接建立一个 server。但请注意，这是一个非常冗长的过程，很多时候，你并不需要这么做。 在这儿，我们指定使用 NioServerSocketChannel 类来实例化一个新的 Channel 来接收进来的连接。 在这儿指定的处理器通常由新接收的 Channel 进行评估。ChannelInitializer 是一个特殊的处理器，用来帮助用户配置一个新的 Channel。很可能你会想通过添加处理器,如 DiscardServerHandler ,来配置新 Channel 的 ChannelPipeline ,用来实现你的网络应用。随着应用变得复杂，你会往管道添加更多的处理器，最终你可能会把这个匿名类提取为一个单独的类。 你可以设置指定 Channel 实现的特定参数。我们在写一个 TCP/IP 服务，所以我们可以设置一些 socket 的选项，比如 tcpNoDelay 和 keepAlive 。请参照 ChannelOption API 文档以及特定的 ChannelConfig 实现，以获得有关 ChannelOptionS 支持的概述。 你有注意到 option() 和 childOption 方法了吗？ option() 是为 NioServerSocketChannel 用来接收进来的连接。 childOption() 是为被父通道 ServerChannel 接收到的 ChannelS ，在本例中指的是 NioServerSocketChannel。 我们现在已经准备好了。剩下的就是绑定端口和启动服务了。在这儿，我们绑定了机器所有网卡的 8080 端口。你现在可以调用多次 bind() 方法（用不同的绑定地址）。 恭喜你！你已经基于 Netty 完成里你的第一个服务端程序。 &lt;未完待续&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[为什么要造轮子]]></title>
      <url>%2F2017%2F03%2F06%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%80%A0%E8%BD%AE%E5%AD%90%2F</url>
      <content type="text"><![CDATA[当我在 oschina.net 上以 java orm 作为关键词进行搜索的时候，共找到529条结果。那么我为什么还是要写 ur-orm 呢？ 与DB交互的时候，只想调用一个方法就行了 虽然看上去不够高大上，但在代码里写sql感觉就是舒服呀😌 与查询的时候返回个对象用起来遍历，当然了，这也是 ORM 框架最起码要实现的 轻量级，轻量级，还是轻量级。在大家都在说轻量级的时候，要做到真正但轻量级，换ORM的时候，只会觉得当前的代码不够用，而不是发现当前的一堆配置，代码是多余的，对另一个框架来说。当然了，这有点儿偏激。 重要的是，要对味儿。 用了好多年的 MyBatis 了，至今还是觉得这是个好的框架，但实在不想在项目开始的时候先来一拖它的配置，不管是 resultMap 还是其它。 JPA 让 Java 开发有了点儿敏捷的意思了，但有时候封装的太深，用起来让人不知所措。 当然了，这个轮子，说不定哪天也会变得让人又爱又恨。😄]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[要做的事情]]></title>
      <url>%2F2017%2F03%2F03%2F%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85%2F</url>
      <content type="text"><![CDATA[有很多事情要做，把他们列下来 side project ur-orm 学习 vue.js netty 英语 读书 三体 java虚拟机规范 响应式web设计 产出 git练习代码提交 学习笔记 为什么要学前端 作为一个一直在写后段代码的人，有着一颗产品的❤️，想要把自己的idea展示出来可不是看着 terminal 中应用启动成功了就行了的。 时间过的很快，2017年的1/6又没了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo部署笔记]]></title>
      <url>%2F2017%2F03%2F01%2FHexo%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[主题选择 hexo-theme-apollo 网上找了个水滴的图标，好看，一点点寓意。 多客户端写文章的问题 hexo d 执行后 hexo 将 hexo g 生成的 public 文件夹下的静态文件部署到目标服务器，其它 hexo 环境相关的内容则还在本机上，这样势必导致之前辛苦装的一系列插件，主题之类的东西没有办法同步到其它机器上，更换电脑是件麻烦事。 暂且想到集中解决方案 使用 dropbox，OneDriver 之类的文件同步服务同步源文件 另外建一个repo同步源文件 网络上还有一种将源文件提交到新分支的做法 看了hexo init 后的 blog_dir ,显然 hexo 已经考虑到这方面的问题，支持将源文件提交到 git 仓库中，因为 .gitignore 已经初始化好了。 作为一个稍微有点儿强迫症的狮子座，决定采用新建分支的方法 123456cd $blog_dirgit initgit add *git checkout -b $branch_namegit remote add origin git@github.com:xxxx/xxxx.github.io.gitgit push origin $branch_name:$branch_name 需要注意的是，_config.yml 中 deploy 节点不要暴露敏感信息。 在新的客户端，只需要将代码clone下来，checkout到相应分支，npm install -g hexo-cli,npm install 之后 new, generate, deploy 即可 关于源码的维护，可以将当前 repo 的 default branch 设置为源码的分支，以方便后续维护。]]></content>
    </entry>

    
  
  
</search>
